<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create this object so it is around all the time. Properties.

/*
Usage: 

Create this object so it is around all the time. 
To make something pathfind it just needs to be a child of obj_pathfindable.
you can then call find_path() to queue it up 
event_user(10) gets run when the path has been found

*/

randomize()
gml_release_mode(1)

show_debug_overlay(true)
instance_create(0,0,obj_pathfinding_manager) // make the manager that will queue tasts for this object. 


//#macro CHECKSPERFRAME 40 // bigger numbers will finish pathfinding in less frames but take up more CPU during those frames 
// PF_CPU_TIME = game_get_speed(gamespeed_microseconds)*0.5 // microseconds

// lower numbers are faster
enum ground {
   roadfast = 1,
   roadslow = 4,
   grass = 25,
   mud = 50,
   impassable = PF_LARGESTNUMBER
}

route = path_add() // where we save it 
path_set_closed(route, false)
path_set_kind(route,1)
path_set_precision(route,2)

pf_queue_x = ds_priority_create()
pf_queue_y = ds_priority_create()

h_cells = 40
v_cells = 40

start_x = 0
start_y = 0
end_x = 30
end_y = 30

terrain = ds_grid_create(h_cells,v_cells)
fastest = ds_grid_create(h_cells,v_cells)
checked = ds_grid_create(h_cells,v_cells)

processing = false
finished_spreadout = false

object_id = -1 // would you like an object to have a callback?

// for timing the pathfindin 
pf_timer_start = 0
pf_timer_end = 0 // used for debugging only 
pf_debug_loop_count = 0 // debugging the number of times it looped before it was told to stop 
pf_debug_frames_to_calculate_last_path = 0

/// a few different ways I have played with doing the map, its crap because you will want to plug your own one in. 
/*
terrain = load_csv("terrain1.csv")

// make everything empty grass 
for (var i = 0; i &lt; h_cells; ++i) {
for (var j = 0; j &lt; v_cells; ++j) {
    if (terrain[# i,j] == "" or terrain[# i,j] == undefined) {terrain[# i,j] = ground.grass}
else {terrain[# i,j] = real(terrain[# i,j])}
}
}
*/

// grass
ds_grid_set_region(terrain, 0, 0, h_cells, v_cells, ground.grass);

// mud
ds_grid_set_region(terrain, 5, 5, 12, 14, ground.mud);
ds_grid_set_region(terrain, 0, 24, 4, 30, ground.mud);

// v roads
ds_grid_set_region(terrain, 10, 0, 10, 30, ground.roadslow);
ds_grid_set_region(terrain, 20, 0, 20, 30, ground.roadslow);

// h roads
ds_grid_set_region(terrain, 7, 5, 17, 5, ground.roadslow);
ds_grid_set_region(terrain, 8, 10, 20, 10, ground.roadslow);
ds_grid_set_region(terrain, 2, 15, 12, 15, ground.roadslow);
ds_grid_set_region(terrain, 15, 20, 18, 20, ground.roadslow);
ds_grid_set_region(terrain, 14, 22, 23, 22, ground.roadslow);

// super fast
ds_grid_set_region(terrain, 30, 0, 30, 30, ground.roadfast);
ds_grid_set_region(terrain, 0, 23, 0, 30, ground.roadfast);
ds_grid_set_region(terrain, 0, 30, 5, 30, ground.roadfast);

// for drawing 
cell_width = 26
cell_height = 26



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Cleanup


path_delete(route)

ds_grid_destroy(terrain)
ds_grid_destroy(fastest)
ds_grid_destroy(checked)

ds_priority_destroy(pf_queue_x)
ds_priority_destroy(pf_queue_y)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Process pathfinding



if (processing == true) {
	find_path_mainloop()
}
if (finished_spreadout = true) {
	finished_spreadout = false	
	find_path_end() // turn the spreadout into a path
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw cells and info

draw_set_colour(c_green)
draw_rectangle(0,0,h_cells*cell_width,v_cells*cell_height,false)

for (var h = 0; h &lt; h_cells; ++h) {
	for (var v = 0; v &lt; v_cells; ++v) {
		
		switch (terrain[# h,v]) {
		    case ground.roadfast:
				draw_set_colour(c_ltgray)
				draw_rectangle(h*cell_width,v*cell_height,(h+1)*cell_width,(v+1)*cell_height,false)
		    break;
		    case ground.roadslow:
				draw_set_colour(c_gray)
				draw_rectangle(h*cell_width,v*cell_height,(h+1)*cell_width,(v+1)*cell_height,false)
		    break;
		    case ground.mud:
				draw_set_colour(c_maroon)
				draw_rectangle(h*cell_width,v*cell_height,(h+1)*cell_width,(v+1)*cell_height,false)
		    break;
		    case ground.impassable:
				draw_set_colour(c_black)
				draw_rectangle(h*cell_width,v*cell_height,(h+1)*cell_width,(v+1)*cell_height,false)
		    break;
		}
		
		// for debugging:
		var todisplay = fastest[# h,v]
		if (todisplay != PF_LARGESTNUMBER) { 
			draw_set_colour(c_black)
			draw_text(h*cell_width,v*cell_height,round(todisplay))
			//draw_text(h*cell_width,v*cell_height,"*")
		} else {
			draw_set_colour(c_red)
			//draw_text(h*cell_width,v*cell_height,"x")
		}
/*		
		var todisplay = checked[# h,v]
		if (todisplay != PF_LARGESTNUMBER) { 
			if (todisplay != PF_LARGESTNUMBER-1) { 
				draw_set_colour(c_blue)
				//draw_text(h*cell_width,(v*cell_height)+13,round(todisplay))
				draw_text(h*cell_width,(v*cell_height)+13,"*")
			} else {
				draw_set_colour(c_aqua)
				draw_text(h*cell_width,(v*cell_height)+13,"#")
			}
		} else {
			draw_set_colour(c_red)
			//draw_text(h*cell_width,(v*cell_height)+13,"x")
		}
*/
	}
}


// draw the last path you made
draw_set_colour(c_white)
draw_path(route,cell_width/2,cell_height/2,true)

// draw the whole database of paths 
var size = ds_map_size(obj_pathfinding_manager.pathfinding_database) ;
var key = ds_map_find_first(obj_pathfinding_manager.pathfinding_database);
for (var i = 0; i &lt; size; i++;) {
	draw_path(obj_pathfinding_manager.pathfinding_database[? key],0,0,true)
	key=ds_map_find_next(obj_pathfinding_manager.pathfinding_database, key);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
